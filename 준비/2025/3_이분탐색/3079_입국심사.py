'''
이번 3_이분탐색 문제에서 중심이 되는 값은 주어진 시간에 얼마나 많은 사람들이 통과할 수 있을까이다.
최대로 걸리는 것 -> 최대 심사대에서 M 명이 모두 심사받는 것
최소로 걸리는 것 -> 0
'''

'''
배운 점
> 너무 뭔가 로직이 복잡하다. 하지만 그리디하게 가면 시간이 정말 많이 걸릴 것이 보인다
> "그게 과연 필요할까?" || 근데 사실 생각은 했다.. 이거 할바엔 다 돌리는데 다 돌리면 무조건 시간 초과다.. 하는 생각까진 함
> 생각 닿지 않았음
>> "어떻게 줄을 세울까?" 는 중요하지 않았다.
>> "N 시간 안에 몇 명이 세워질 수 있을까?"
>>> 결국 각 [정해진 시간//심사대] 를 하면 심사대가 쉬지않고 사람을 돌리게 되므로, 최대 인원 처리 수이다
>>> 이렇게 돌린 것보다 빠르게 처리할 수 없다
>>> 따라서 각 심사대의 [정해진 시간(TG) 안에 구해진 인원]의 합이 정해진 시간안에 처리할 수 있는 "최대 인원 수" 임이 보장된다
>>> 어떻게 세우든, 어떤 조합으로 세웠든 "각 심사대가 쉴새 없이 돌릴 수 있을 때"가 가장 빨리 처리할 수 있는 것이다
>>> 따라서, 자연스럽게 가능 인원으로 이분탐색으로 찾아나가면, 최소 시간을 구할 수 있다
>>> -"이 시간 이하로는 가장 빨리 돌린다 해도 절대 이 인원을 처리할 수 없다"- 를 이해해야 함
>>> 어떻게 돌렸는지는 상관 없다. 어떻게든 쉴새 없이 돌렸다고 한다!! 가 중요한 가정인 것이다

>>> O() 가 너무너무 복잡한데 너무 생각이 깊어지고 이건 말이 안되는데.. 라는 생각이 들 때
>>> 생각이 잘못된게 맞다는걸 인정해야 한다
>>> 그리고 "어떻게 하면 어떤 조건을 만족하는 최소/최대의 값을 찾을 수 있지?" 란 생각을 해보면 된다
>>> 이번에도 "모든 검색대를 쉴새 없이 돌려야 시간의 최솟값이 나온다" 가 되어야 하고, 
>>> 이렇게 된다면 자연스럽게, 각 검색대가 TG 시간동안 돌릴 수 있는 인원을 계산해보는 생각으로 이어질 수 있다.
>>> 그러면 TG 시간동안 "이 인원보다는 더 돌릴 수 없다" 라는 생각으로 이어지고, 
>>> 원하는 TG 값이 되었을 때 "어 그럼 이 시간도 이 인원을 돌릴 수 있나?" 이기 때문에 이분 탐색을 줄여나가면
>>> 결국 원하는 답이 얻어질 수 있다

'''

import sys


def max_process_sum_of_each_line(tg, each_time):
    sum_ppl = 0
    for time in each_time:  # 각 검색대는 1명당 time 걸림
        sum_ppl += tg // time  # 처리할 수 있는 인원 수가 나온다
    return sum_ppl


def solution(N, M, each_time):
    # mid 설정이 핵심
    st = 0  # 0 # 처리 시간은 1분부터이고, 친구 수도 1명 부터 이므로, 0은 불가능하다
    end = max(each_time) * M  # 가장 오래 걸리는 녀석한테만 다 세운다
    while st + 1 < end:
        mid = (st + end) // 2
        # mid 일 때 각 검색대는 최대 몇명까지 뽑아낼 수 있었는가?
        # 핵심 = "최대로 돌렸어도 이 시간이면 이 인원은 가능하구나? 좀 더 줄여볼까? "
        if max_process_sum_of_each_line(mid, each_time) >= M:  # mid 줄여도 됨
            end = mid
        else:
            st = mid
    # st+1 = end 에서, end 쪽에서 당겨와지므로 end 가 경계이다
    return end

input = sys.stdin.readline

N, M = map(int, input().split())
each_time = []
for _ in range(N):
    each_time.append(int(input()))

print(solution(N, M, each_time))
