import sys


def solution(N, C, houses):
    # 길이에 초점.
    # mid 라는 길이가 있다.
    # houses 안에서 mid 라는 거리가 "가장 큰 인접 거리"라고 두자
    # 그러면 다른 라우터들간의 거리는 mid+1 이상이어야 한다
    # 즉 라우터가 5개 있으면, 거리는 총 4개, 그 중 하나가 mid 여ㅑ야 한다면 나머지는 mid+1 이상
    # 따라서 (C-2)*(mid+1) + mid = 집 시작~끝 최소 거리 (실제 거리)
    ## 최소 거리가 안된다면, mid 로는 안된다는 것!! mid 가 더 줄어야 한다
    ## 최소 거리가 된다면, mid 로도 충분하다는 것!! 더 늘려봐도 된다
    # 최소 mid+1 만큼 * 갯수 + mid 의 길이가 houses 전체 길이
    houses.sort()  # 30만 정렬은 필수
    st = 0  # 한집에 하나만 설치 가능 -> 불가
    end = 10e8 + 1  # house 의 크기 만큼?

    if C == 2:  # 두개면 그냥 할 필요도 없이 양 끝에 놓으면 된다
        return houses[N - 1] - houses[0]
    while st + 1 < end:
        mid = (st + end) // 2
        land_length = houses[N - 1] - houses[0]
        minimum_land_length = mid * (C - 1)
        # land 가 min 보다 작으면, mid 는 최대 거리가 아니다
        if land_length > minimum_land_length:  # 가능하잖아. 그보다 더 큰것도 다 되는거긴 한거잖아
            # 인접하지 않은 녀석들은,4,5,6 상관이 없음
            st = mid  # 그래서 4도 되겠거니 했는데 4가 안되는거임
        else:  # 같으면 안되는거임
            end = mid
    return int(st)


# 항상 뭔가 한끝차이다
# 좌표를 돌리면 천만을 돌리는거라 생각했다.. 그게 아니라 300,000 돌리는거임..
## 내 생각이 위에서 어디까지 이어졌었냐면
## 저렇게 하면 11111111 1000000 이런 상황에서 망하지 않나..? 이런 생각이 들었는데, 그냥 된다고 생각해버림
## 그래서 실제 좌표를 고려 해야하지 않나..? 이런 생각을 했는데 천만을 돌리는거라 좌표는 절대 아니라 생각해버림..
## 약간의 함정이라고 봐도 될듯하다!!!! 아무도 안 속이려 했는데 혼자 빠진!!
## 아무튼, mid 에 대해서, 이게 가장 큰 값이라면? 부터 다시 생각해보자


## 이런 모습을 그려보면 되는거다 (이분 탐색은 상상력도 좀 중요한 것 같아 - 최대/최소 이런거 - 입국 심사도 말이 좀 중요했다)
## 내가 몇 개 배치할 수 있는지 모른채, 일단 N 보단 다 길어야해~! 하면서 배치하면서 길을 가는거임
## 그러면 N 넘으면 당연히 일단 놓으면서 가겠지? 그러다가 다 놨는데 길이가 많이 남았어
## 에이~ 그럼 N 보다 더 커도 되겠다!! 하고 다시 수거하며 돌아가는 느낌임
def sol2(N, C, houses):
    # 제일 낮은 거리는 0보단 커야하는 것, 한칸이 1
    # 제일 먼 거리는 큰값과 작은값의 차이 +1
    houses.sort()
    st = 0
    end = houses[-1] - houses[0] + 1
    while st + 1 < end:
        mid = (st + end) // 2
        last_pos = houses[0]  # 당연히 처음부터 놔야지, 널찍널찍 최대한 벌려야 하니까 (지금 공유기 갯수 몇개 필요한지 모르는거임)
        cnt = 1
        # a 는 위치, O(300,000) ##### 니가 생각한대로, "실제 좌표 고려를 해야하는거 아닌가?" 에서, 무조건 맞다로 갔어야 함, 그랬으면 조건 다시 봤을 듯
        for i in range(1, len(houses)):
            if houses[i] - last_pos >= mid:  # 놔야지 여기에
                last_pos = houses[i]
                cnt += 1

        # C 개를 못놨어 -> 너무 큼
        if cnt < C:
            end = mid
        # C 개를 놓고도 남음 -> 더 커도 됨 (쭉쭉 뻣어나가면 된다)
        else:
            st = mid
    return st


N, C = map(int, input().split())  # 집 갯수, 공유기 갯수
houses = []  # 집 위치 총 30만개, 하나당 10억까지의 좌표
for _ in range(N):
    houses.append(int(input()))
print(sol2(N, C, houses))
