NODE_CNT = 6
NODE_MAP = [
    [0, 0, 0, 0, 0, 0, 0],
    [0, 0, 2, 5, 1, 0, 0],
    [0, 2, 0, 3, 2, 0, 0],
    [0, 5, 3, 0, 3, 1, 5],
    [0, 1, 2, 3, 0, 1, 0],
    [0, 0, 0, 1, 1, 0, 2],
    [0, 0, 0, 5, 0, 2, 0]
]

# 현재 node 에서 갈 곳 [] 에 대해 방문하지 않았으면 가중치가 가장 작은 녀석을 반환해준다


# 과제
# 1번 > 일반 다익스트라를 구현해보아라
min_paths = [-1] * (NODE_CNT + 1)
visited = [0] * (NODE_CNT + 1)

for i in range(1, NODE_CNT + 1):
    min_paths[i] = NODE_MAP[1][i]

# 얘를 기준으로 계속 돌릴 것이다
'''현재 갈 수 있는 간선 중 제일 비용이 적은, 혹은 앞에 있는 node 로 가면 된다'''
def smallestIndex(node):
    tmp = NODE_MAP[node] # 여기에서 제일 비용이 적은 node 로 갈 것인데, 방문한 것이면 안된다





# 2번 > PQ 를 사용해, NlogN 의 다익스트라를 구현해보아라
# 3번 > 이중배열을 사용하지 않고, 메모리가 최적화된 다익스트라를 구현해 보아라 ( 나는 일단 dict 로 하는 생각이 듬 )